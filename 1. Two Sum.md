#1. Two Sum

	Given an array of integers, return indices of the two numbers such that they add up to a specific 
	target.

	You may assume that each input would have exactly one solution.

	Example:
	Given nums = [2, 7, 11, 15], target = 9,

	Because nums[0] + nums[1] = 2 + 7 = 9,
	return [0, 1].


我是先做的three sum， 再做到这道题的时候，就想着用之前的思路：1.排序；
2. 两端缩进，num[i] + num[j] > sum 的时候缩进左边，反之，右边。
3. 根据value去原array中找index. 

用这种方法做出来了，但是效率不高。主要在3. 因为在没有排序的int[] 中搜索，很麻烦。
开始用的是if比较，后来发现搜索两个相同value的index的时候，又需要嵌套。
于是换了Integer [], 但这样很慢。

反思就是变量类型，在3 sum中，返回类型是list. 所以就自然很多。
但这题返回值是array, 而且顺序很重要，所以，用array + for + if 的方法就很费力气。

后来在网上搜了下，用hashmap。看了下他们的code,确实顺畅很多啊。速度也快很多。


``` java

	public int[] twoSum(int[] nums, int target) {

	  int[] original = new int[nums.length];
		  System.arraycopy(nums, 0, original, 0, nums.length);
		  int[] result = new int [2]; 
		  
		  Arrays.sort(nums);
		  int i = 0;
		  int j = nums.length-1;
		  
		  while (i<j){
			  int sum = nums[i] + nums[j];
				if (sum > target){
					j--; 
				}
				else if (sum < target)
					i++; 
				else
					break; 
			  }

		int num1 = nums[i];
		int num2 = nums[j];

		
		List<Integer> indexs = new ArrayList<Integer>();
		for (int p=0; p< original.length;  p++){
			if (original[p] == num1 || original[p] == num2){
				indexs.add(p);
			}
			
		}
		Integer [] result2 = indexs.toArray(new Integer[indexs.size()]);
		result = Arrays.stream(result2).mapToInt(Integer:: intValue).toArray(); 
		return result; 
		
		/** method 2*/
		
//	    HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();
//			int[] defaultResult = {0, 0};
//			for (int i = 0; i < nums.length; i++) {
//				if (map.get(target-nums[i]) != null ) {
//					int[] result = {map.get(target-nums[i]) , i };
//					return result;
//				}
//				map.put(nums[i], i);
//			}
//			return defaultResult;

}

